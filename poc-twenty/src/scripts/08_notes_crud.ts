import { apiClient } from '../apiClient';

/**
 * Script 08: Notes CRUD (mock data) for a Person
 *
 * No CLI flags by design.
 * Edit the CONFIG section below, then run:
 *   bun run src/scripts/08_notes_crud.ts
 *
 * What it does:
 * - Generates a deterministic set of mock Notes (seeded).
 * - For each note: find existing by title → create (with upsert) → ensure NoteTarget (person link) → update → optionally delete.
 * - Optional best-effort cleanup by namespace prefix.
 */

// =========================
// CONFIG (edit me)
// =========================

const DRY_RUN = false;
const DEPTH: 0 | 1 = 0;
const UPSERT = true;
const SOFT_DELETE = true;

// Person selection
// - Prefer PERSON_ID.
// - If omitted, we will attempt a best-effort lookup by PERSON_PRIMARY_EMAIL.
const PERSON_ID: string | undefined = 'f8c19c41-1407-4c31-b136-6e6927a7280c';
const PERSON_PRIMARY_EMAIL: string | undefined = undefined; // e.g. anita.menon@example.com

// Mock generation controls
const MOCK_NAMESPACE = 'poc-twenty-notes';
const SEED = 42;
const NOTE_COUNT = 5;

// Cleanup / delete behavior
// - If false, notes (and their noteTargets) are left in place for UI inspection.
const DELETE_NOTES_AT_END = false;
// - If true, we delete the NoteTargets we created (unlink notes from the person).
//   This is independent of DELETE_NOTES_AT_END (you may want to unlink-but-keep notes).
//   Default behavior: delete targets when deleting notes.
const DELETE_NOTE_TARGETS_AT_END = DELETE_NOTES_AT_END;
// Best-effort convenience cleanup: delete existing notes with titles matching `${MOCK_NAMESPACE}/${SEED}/%`.
const CLEANUP_EXISTING_BY_NAMESPACE = false;

// =========================
// Types (lightweight)
// =========================

type NoteBodyV2 = {
  blocknote?: string;
  markdown?: string;
};

type NotePayload = {
  position?: number;
  title?: string;
  bodyV2?: NoteBodyV2;
  createdBy?: {
    source?: 'EMAIL' | 'CALENDAR' | 'WORKFLOW' | 'AGENT' | 'API' | 'IMPORT' | 'MANUAL' | 'SYSTEM' | 'WEBHOOK';
  };
};

type NoteResponse = NotePayload & {
  id: string;
  createdAt?: string;
  updatedAt?: string;
  deletedAt?: string;
};

type NoteTargetPayload = {
  noteId: string;
  personId: string;
};

type NoteTargetResponse = NoteTargetPayload & {
  id: string;
  createdAt?: string;
  updatedAt?: string;
  deletedAt?: string;
};

// =========================
// Helpers
// =========================

function quoteFilterValue(value: string): string {
  // OpenAPI examples quote string filters: createdAt[gte]:"2023-01-01"
  return `"${value.replaceAll('"', '\\"')}"`;
}

function mulberry32(seed: number) {
  let a = seed >>> 0;
  return function next(): number {
    a |= 0;
    a = (a + 0x6d2b79f5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pick<T>(rng: () => number, items: readonly T[]): T {
  const idx = Math.floor(rng() * items.length);
  return items[Math.min(items.length - 1, Math.max(0, idx))]!;
}

function randIntInclusive(rng: () => number, min: number, max: number): number {
  const lo = Math.min(min, max);
  const hi = Math.max(min, max);
  return Math.floor(rng() * (hi - lo + 1)) + lo;
}

function buildMockTitle(index: number, count: number): string {
  // stable title derived from (namespace, seed, index)
  return `${MOCK_NAMESPACE}/${SEED}/${index}: Mock Note ${index + 1}/${count}`;
}

function buildMockNotes(count: number): NotePayload[] {
  const rng = mulberry32(SEED);

  const topics = [
    'KYC follow-up',
    'Portfolio rebalancing',
    'Risk profile update',
    'Tax planning',
    'Investment thesis',
    'Client onboarding',
    'Quarterly review',
  ] as const;

  const tones = ['Action items', 'Summary', 'Observations', 'Next steps'] as const;

  const notes: NotePayload[] = [];

  for (let i = 0; i < count; i++) {
    const topic = pick(rng, topics);
    const tone = pick(rng, tones);
    const bulletCount = randIntInclusive(rng, 2, 5);

    const bullets: string[] = [];
    for (let b = 0; b < bulletCount; b++) {
      bullets.push(`- ${topic} — mock bullet ${b + 1} (seed=${SEED}, i=${i})`);
    }

    const title = buildMockTitle(i, count);
    const markdown = [
      `**${tone}**`,
      '',
      `Generated by ${MOCK_NAMESPACE} (seed=${SEED}, index=${i}).`,
      '',
      ...bullets,
      '',
      `Timestamp: ${new Date().toISOString()}`,
    ].join('\n');

    notes.push({
      position: i + 1,
      title,
      bodyV2: {
        markdown,
      },
      createdBy: {
        source: 'API',
      },
    });
  }

  return notes;
}

async function resolvePersonId(): Promise<string> {
  if (PERSON_ID) return PERSON_ID;
  if (!PERSON_PRIMARY_EMAIL) throw new Error('CONFIG error: set PERSON_ID or PERSON_PRIMARY_EMAIL.');

  // Best-effort lookup. Filter syntax can vary; we mirror patterns used elsewhere in this repo.
  try {
    const { data } = await apiClient.get('people', {
      params: {
        filter: `emails.primaryEmail[eq]:${quoteFilterValue(PERSON_PRIMARY_EMAIL)}`,
        limit: 5,
        depth: 0,
      },
    });

    const people = data?.data?.people ?? data?.data?.persons ?? data?.data?.people ?? [];
    const match = Array.isArray(people)
      ? people.find((p: any) => p?.emails?.primaryEmail === PERSON_PRIMARY_EMAIL)
      : undefined;

    const id: string | undefined = match?.id;
    if (id) return id;
  } catch {
    // fall through
  }

  // Fallback: fetch a small list and match client-side.
  const { data } = await apiClient.get('people', {
    params: {
      limit: 50,
      depth: 0,
    },
  });

  const people = data?.data?.people ?? [];
  const match = people.find((p: any) => p?.emails?.primaryEmail === PERSON_PRIMARY_EMAIL);
  const id: string | undefined = match?.id;

  if (!id) throw new Error(`Could not resolve person by email: ${PERSON_PRIMARY_EMAIL}`);
  return id;
}

async function findNoteByTitle(title: string): Promise<NoteResponse | undefined> {
  const { data } = await apiClient.get('notes', {
    params: {
      filter: `title[eq]:${quoteFilterValue(title)}`,
      limit: 1,
      depth: 0,
    },
  });

  const notes = data?.data?.notes ?? [];
  return notes[0];
}

async function createNote(payload: NotePayload): Promise<NoteResponse> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would create note:', payload);
    return { ...(payload as NoteResponse), id: `dry-run-note-${payload.title ?? 'note'}` };
  }

  const { data } = await apiClient.post('notes', payload, {
    params: {
      depth: DEPTH,
      upsert: UPSERT,
    },
  });

  const created: NoteResponse | undefined =
    data?.data?.createNote ?? data?.data?.note ?? data?.data?.createNotes?.[0];

  if (!created?.id) {
    throw new Error(`Unexpected create note response: ${JSON.stringify(data)}`);
  }

  return created;
}

async function updateNote(id: string, update: NotePayload): Promise<NoteResponse> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would update note:', { id, update });
    return { ...(update as NoteResponse), id };
  }

  const { data } = await apiClient.patch(`notes/${id}`, update, {
    params: {
      depth: DEPTH,
    },
  });

  const updated: NoteResponse | undefined =
    data?.data?.updateNote ?? data?.data?.note ?? data?.data?.updateNotes?.[0];

  if (!updated?.id) {
    throw new Error(`Unexpected update note response: ${JSON.stringify(data)}`);
  }

  return updated;
}

async function deleteNote(id: string): Promise<{ id: string }> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would delete note:', { id, soft_delete: SOFT_DELETE });
    return { id };
  }

  const { data } = await apiClient.delete(`notes/${id}`, {
    params: {
      soft_delete: SOFT_DELETE,
    },
  });

  const deleted = data?.data?.deleteNote ?? data?.data?.deleteNotes?.[0];
  const deletedId: string | undefined = deleted?.id;

  if (!deletedId) {
    throw new Error(`Unexpected delete note response: ${JSON.stringify(data)}`);
  }

  return { id: deletedId };
}

async function upsertNoteTarget(payload: NoteTargetPayload): Promise<NoteTargetResponse | undefined> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would upsert noteTarget:', payload);
    return { ...payload, id: `dry-run-noteTarget-${payload.noteId}` };
  }

  const { data } = await apiClient.post('noteTargets', payload, {
    params: {
      depth: 0,
      upsert: true,
    },
  });

  const created: NoteTargetResponse | undefined = data?.data?.createNoteTarget ?? data?.data?.noteTarget;
  const id: string | undefined = created?.id;
  return id ? created : undefined;
}

async function listNoteTargetsByNoteId(noteId: string): Promise<NoteTargetResponse[]> {
  const { data } = await apiClient.get('noteTargets', {
    params: {
      filter: `noteId[eq]:${quoteFilterValue(noteId)}`,
      limit: 200,
      depth: 0,
    },
  });

  return data?.data?.noteTargets ?? [];
}

async function deleteNoteTarget(id: string): Promise<{ id: string } | undefined> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would delete noteTarget:', { id, soft_delete: SOFT_DELETE });
    return { id };
  }

  const { data } = await apiClient.delete(`noteTargets/${id}`, {
    params: {
      soft_delete: SOFT_DELETE,
    },
  });

  const deleted = data?.data?.deleteNoteTarget ?? data?.data?.deleteNoteTargets?.[0];
  const deletedId: string | undefined = deleted?.id;
  return deletedId ? { id: deletedId } : undefined;
}

async function cleanupExistingNotesBestEffort(): Promise<void> {
  if (!CLEANUP_EXISTING_BY_NAMESPACE) return;

  const prefix = `${MOCK_NAMESPACE}/${SEED}/`;
  const likePattern = `${prefix}%`;

  console.log('Cleanup enabled. Attempting best-effort cleanup by title prefix:', prefix);

  const { data } = await apiClient.get('notes', {
    params: {
      filter: `title[ilike]:${quoteFilterValue(likePattern)}`,
      limit: 200,
      depth: 0,
    },
  });

  const notes: Array<{ id?: string; title?: string }> = data?.data?.notes ?? [];
  const ids = notes.map((n) => n.id).filter((id): id is string => typeof id === 'string' && id.length > 0);

  if (!ids.length) {
    console.log('Cleanup: no matching notes found.');
    return;
  }

  console.log(`Cleanup: deleting ${ids.length} note(s)...`);

  // Best-effort: delete their noteTargets first (so the person timeline is clean)
  for (const id of ids) {
    const targets = await listNoteTargetsByNoteId(id);
    for (const t of targets) {
      if (t?.id) await deleteNoteTarget(t.id);
    }
    await deleteNote(id);
  }
}

async function main() {
  console.log('Script 08: Notes CRUD (mock data) for a Person');

  const personId = await resolvePersonId();

  const deleteNotesAtEnd = DELETE_NOTES_AT_END;
  const deleteTargetsAtEnd = DELETE_NOTE_TARGETS_AT_END;

  console.log('Config:', {
    DRY_RUN,
    DEPTH,
    UPSERT,
    SOFT_DELETE,
    PERSON_ID: PERSON_ID ?? null,
    PERSON_PRIMARY_EMAIL: PERSON_PRIMARY_EMAIL ?? null,
    resolvedPersonId: personId,
    MOCK_NAMESPACE,
    SEED,
    NOTE_COUNT,
    DELETE_NOTES_AT_END,
    DELETE_NOTE_TARGETS_AT_END,
    CLEANUP_EXISTING_BY_NAMESPACE,
  });

  if (NOTE_COUNT <= 0) {
    throw new Error('CONFIG error: NOTE_COUNT must be > 0.');
  }

  if (CLEANUP_EXISTING_BY_NAMESPACE) {
    await cleanupExistingNotesBestEffort();
  }

  const mockNotes = buildMockNotes(NOTE_COUNT);
  console.log(`Generated ${mockNotes.length} mock note(s).`);

  const createdOrFound: Array<{ id: string; title: string }> = [];
  const noteTargetIds: string[] = [];

  // 1) Find/create and link to person via noteTargets
  for (const note of mockNotes) {
    const title = note.title;
    if (!title) throw new Error('Internal error: generated note missing title.');

    const existing = await findNoteByTitle(title);
    const created = existing
      ? (console.log('Found existing note for title:', title, '->', existing.id), existing)
      : await createNote(note);

    createdOrFound.push({ id: created.id, title });

    const target = await upsertNoteTarget({ noteId: created.id, personId });
    if (target?.id) noteTargetIds.push(target.id);
  }

  // 2) Update (derived; no manual details)
  const updatedIds: string[] = [];
  for (const item of createdOrFound) {
    const nowIso = new Date().toISOString();

    const update: NotePayload = {
      title: `${item.title} (Updated)`,
      bodyV2: {
        markdown: [
          `**Updated**`,
          '',
          `This note was updated by ${MOCK_NAMESPACE} at ${nowIso}.`,
          '',
          `Original title: ${item.title}`,
        ].join('\n'),
      },
    };

    const updated = await updateNote(item.id, update);
    updatedIds.push(updated.id);
  }

  // 3) Delete (optional)
  const deletedTargetIds: string[] = [];
  const deletedNoteIds: string[] = [];

  if (deleteTargetsAtEnd && noteTargetIds.length) {
    console.log(`Deleting ${noteTargetIds.length} noteTarget(s)...`);
    for (const id of noteTargetIds) {
      const deleted = await deleteNoteTarget(id);
      if (deleted?.id) deletedTargetIds.push(deleted.id);
    }
  }

  if (deleteNotesAtEnd) {
    console.log(`Deleting ${createdOrFound.length} note(s)...`);
    for (const item of createdOrFound) {
      const deleted = await deleteNote(item.id);
      deletedNoteIds.push(deleted.id);
    }
  }

  console.log(
    '\nDone. Summary:\n',
    JSON.stringify(
      {
        namespace: MOCK_NAMESPACE,
        seed: SEED,
        count: NOTE_COUNT,
        personId,
        createdOrFound,
        noteTargetIds: deleteTargetsAtEnd ? [] : noteTargetIds,
        updatedIds,
        deletedTargetIds: deleteTargetsAtEnd ? deletedTargetIds : [],
        deletedNoteIds: deleteNotesAtEnd ? deletedNoteIds : [],
      },
      null,
      2,
    ),
  );
}

main().catch((error: any) => {
  const status = error?.response?.status;
  const body = error?.response?.data;
  console.error('❌ Script failed.', {
    status,
    message: error?.message ?? String(error),
    body,
  });
  process.exitCode = 1;
});
