import { apiClient } from '../apiClient';

/**
 * Script 09: Tasks CRUD (mock data) for a Person
 *
 * No CLI flags by design.
 * Edit the CONFIG section below, then run:
 *   bun run src/scripts/09_tasks_crud.ts
 *
 * What it does:
 * - Generates a deterministic set of mock Tasks (seeded).
 * - For each task: find existing by title → create (with upsert) → ensure TaskTarget (person link) → update → optionally delete.
 * - Optional best-effort cleanup by namespace prefix.
 */

// =========================
// CONFIG (edit me)
// =========================

const DRY_RUN = false;
const DEPTH: 0 | 1 = 0;
const UPSERT = true;
const SOFT_DELETE = true;

// Person selection
// - Prefer PERSON_ID.
// - If omitted, we will attempt a best-effort lookup by PERSON_PRIMARY_EMAIL.
const PERSON_ID: string | undefined = 'f8c19c41-1407-4c31-b136-6e6927a7280c';
const PERSON_PRIMARY_EMAIL: string | undefined = undefined; // e.g. anita.menon@example.com

// Mock generation controls
const MOCK_NAMESPACE = 'poc-twenty-tasks';
const SEED = 42;
const TASK_COUNT = 5;

// Due date generation
const BASE_DUE_ISO = '2025-01-15T09:00:00.000Z';
const MIN_DUE_IN_HOURS = 2;
const MAX_DUE_IN_HOURS = 240; // 10 days

// Cleanup / delete behavior
// - If false, tasks (and their taskTargets) are left in place for UI inspection.
const DELETE_TASKS_AT_END = false;
// - If true, we delete the TaskTargets we created (unlink tasks from the person).
//   This is independent of DELETE_TASKS_AT_END (you may want to unlink-but-keep tasks).
//   Default behavior: delete targets when deleting tasks.
const DELETE_TASK_TARGETS_AT_END = DELETE_TASKS_AT_END;
// Best-effort convenience cleanup: delete existing tasks with titles matching `${MOCK_NAMESPACE}/${SEED}/%`.
const CLEANUP_EXISTING_BY_NAMESPACE = false;

// =========================
// Types (lightweight)
// =========================

type TaskStatus = 'TODO' | 'IN_PROGRESS' | 'DONE';

type TaskBodyV2 = {
  blocknote?: string;
  markdown?: string;
};

type TaskPayload = {
  position?: number;
  title?: string;
  bodyV2?: TaskBodyV2;
  dueAt?: string;
  status?: TaskStatus;
  createdBy?: {
    source?: 'EMAIL' | 'CALENDAR' | 'WORKFLOW' | 'AGENT' | 'API' | 'IMPORT' | 'MANUAL' | 'SYSTEM' | 'WEBHOOK';
  };
  // per plan: leave tasks unassigned (no assigneeId)
  assigneeId?: undefined;
};

type TaskResponse = TaskPayload & {
  id: string;
  createdAt?: string;
  updatedAt?: string;
  deletedAt?: string;
};

type TaskTargetPayload = {
  taskId: string;
  personId: string;
};

type TaskTargetResponse = TaskTargetPayload & {
  id: string;
  createdAt?: string;
  updatedAt?: string;
  deletedAt?: string;
};

// =========================
// Helpers
// =========================

function quoteFilterValue(value: string): string {
  // OpenAPI examples quote string filters: createdAt[gte]:"2023-01-01"
  return `"${value.replaceAll('"', '\\"')}"`;
}

function hoursToMs(hours: number) {
  return hours * 60 * 60_000;
}

function addHours(iso: string, hours: number): string {
  return new Date(new Date(iso).getTime() + hoursToMs(hours)).toISOString();
}

function mulberry32(seed: number) {
  let a = seed >>> 0;
  return function next(): number {
    a |= 0;
    a = (a + 0x6d2b79f5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pick<T>(rng: () => number, items: readonly T[]): T {
  const idx = Math.floor(rng() * items.length);
  return items[Math.min(items.length - 1, Math.max(0, idx))]!;
}

function randIntInclusive(rng: () => number, min: number, max: number): number {
  const lo = Math.min(min, max);
  const hi = Math.max(min, max);
  return Math.floor(rng() * (hi - lo + 1)) + lo;
}

function buildMockTitle(index: number, count: number): string {
  // stable title derived from (namespace, seed, index)
  return `${MOCK_NAMESPACE}/${SEED}/${index}: Mock Task ${index + 1}/${count}`;
}

function buildMockTasks(input: { count: number; baseDueIso: string }): TaskPayload[] {
  const rng = mulberry32(SEED);

  const topics = [
    'Send KYC reminder',
    'Schedule portfolio review',
    'Draft investment memo',
    'Collect tax documents',
    'Confirm risk profile',
    'Prepare onboarding pack',
    'Follow up on pending signatures',
  ] as const;

  const tasks: TaskPayload[] = [];

  for (let i = 0; i < input.count; i++) {
    const topic = pick(rng, topics);
    const dueInHours = randIntInclusive(rng, MIN_DUE_IN_HOURS, MAX_DUE_IN_HOURS);

    const title = buildMockTitle(i, input.count);
    const dueAt = addHours(input.baseDueIso, dueInHours);

    const markdown = [
      `**Task**`,
      '',
      `Generated by ${MOCK_NAMESPACE} (seed=${SEED}, index=${i}).`,
      '',
      `- Topic: ${topic}`,
      `- Due: ${dueAt}`,
    ].join('\n');

    tasks.push({
      position: i + 1,
      title,
      dueAt,
      status: 'TODO',
      bodyV2: {
        markdown,
      },
      createdBy: {
        source: 'API',
      },
    });
  }

  return tasks;
}

async function resolvePersonId(): Promise<string> {
  if (PERSON_ID) return PERSON_ID;
  if (!PERSON_PRIMARY_EMAIL) throw new Error('CONFIG error: set PERSON_ID or PERSON_PRIMARY_EMAIL.');

  // Best-effort lookup. Filter syntax can vary; we mirror patterns used elsewhere in this repo.
  try {
    const { data } = await apiClient.get('people', {
      params: {
        filter: `emails.primaryEmail[eq]:${quoteFilterValue(PERSON_PRIMARY_EMAIL)}`,
        limit: 5,
        depth: 0,
      },
    });

    const people = data?.data?.people ?? data?.data?.persons ?? data?.data?.people ?? [];
    const match = Array.isArray(people)
      ? people.find((p: any) => p?.emails?.primaryEmail === PERSON_PRIMARY_EMAIL)
      : undefined;

    const id: string | undefined = match?.id;
    if (id) return id;
  } catch {
    // fall through
  }

  // Fallback: fetch a small list and match client-side.
  const { data } = await apiClient.get('people', {
    params: {
      limit: 50,
      depth: 0,
    },
  });

  const people = data?.data?.people ?? [];
  const match = people.find((p: any) => p?.emails?.primaryEmail === PERSON_PRIMARY_EMAIL);
  const id: string | undefined = match?.id;

  if (!id) throw new Error(`Could not resolve person by email: ${PERSON_PRIMARY_EMAIL}`);
  return id;
}

async function findTaskByTitle(title: string): Promise<TaskResponse | undefined> {
  const { data } = await apiClient.get('tasks', {
    params: {
      filter: `title[eq]:${quoteFilterValue(title)}`,
      limit: 1,
      depth: 0,
    },
  });

  const tasks = data?.data?.tasks ?? [];
  return tasks[0];
}

async function createTask(payload: TaskPayload): Promise<TaskResponse> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would create task:', payload);
    return { ...(payload as TaskResponse), id: `dry-run-task-${payload.title ?? 'task'}` };
  }

  const { data } = await apiClient.post('tasks', payload, {
    params: {
      depth: DEPTH,
      upsert: UPSERT,
    },
  });

  const created: TaskResponse | undefined = data?.data?.createTask ?? data?.data?.task ?? data?.data?.createTasks?.[0];

  if (!created?.id) {
    throw new Error(`Unexpected create task response: ${JSON.stringify(data)}`);
  }

  return created;
}

async function updateTask(id: string, update: TaskPayload): Promise<TaskResponse> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would update task:', { id, update });
    return { ...(update as TaskResponse), id };
  }

  const { data } = await apiClient.patch(`tasks/${id}`, update, {
    params: {
      depth: DEPTH,
    },
  });

  const updated: TaskResponse | undefined = data?.data?.updateTask ?? data?.data?.task ?? data?.data?.updateTasks?.[0];

  if (!updated?.id) {
    throw new Error(`Unexpected update task response: ${JSON.stringify(data)}`);
  }

  return updated;
}

async function deleteTask(id: string): Promise<{ id: string }> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would delete task:', { id, soft_delete: SOFT_DELETE });
    return { id };
  }

  const { data } = await apiClient.delete(`tasks/${id}`, {
    params: {
      soft_delete: SOFT_DELETE,
    },
  });

  const deleted = data?.data?.deleteTask ?? data?.data?.deleteTasks?.[0];
  const deletedId: string | undefined = deleted?.id;

  if (!deletedId) {
    throw new Error(`Unexpected delete task response: ${JSON.stringify(data)}`);
  }

  return { id: deletedId };
}

async function upsertTaskTarget(payload: TaskTargetPayload): Promise<TaskTargetResponse | undefined> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would upsert taskTarget:', payload);
    return { ...payload, id: `dry-run-taskTarget-${payload.taskId}` };
  }

  const { data } = await apiClient.post('taskTargets', payload, {
    params: {
      depth: 0,
      upsert: true,
    },
  });

  const created: TaskTargetResponse | undefined = data?.data?.createTaskTarget ?? data?.data?.taskTarget;
  const id: string | undefined = created?.id;
  return id ? created : undefined;
}

async function listTaskTargetsByTaskId(taskId: string): Promise<TaskTargetResponse[]> {
  const { data } = await apiClient.get('taskTargets', {
    params: {
      filter: `taskId[eq]:${quoteFilterValue(taskId)}`,
      limit: 200,
      depth: 0,
    },
  });

  return data?.data?.taskTargets ?? [];
}

async function deleteTaskTarget(id: string): Promise<{ id: string } | undefined> {
  if (DRY_RUN) {
    console.log('[DRY_RUN] would delete taskTarget:', { id, soft_delete: SOFT_DELETE });
    return { id };
  }

  const { data } = await apiClient.delete(`taskTargets/${id}`, {
    params: {
      soft_delete: SOFT_DELETE,
    },
  });

  const deleted = data?.data?.deleteTaskTarget ?? data?.data?.deleteTaskTargets?.[0];
  const deletedId: string | undefined = deleted?.id;
  return deletedId ? { id: deletedId } : undefined;
}

async function cleanupExistingTasksBestEffort(): Promise<void> {
  if (!CLEANUP_EXISTING_BY_NAMESPACE) return;

  const prefix = `${MOCK_NAMESPACE}/${SEED}/`;
  const likePattern = `${prefix}%`;

  console.log('Cleanup enabled. Attempting best-effort cleanup by title prefix:', prefix);

  const { data } = await apiClient.get('tasks', {
    params: {
      filter: `title[ilike]:${quoteFilterValue(likePattern)}`,
      limit: 200,
      depth: 0,
    },
  });

  const tasks: Array<{ id?: string; title?: string }> = data?.data?.tasks ?? [];
  const ids = tasks.map((t) => t.id).filter((id): id is string => typeof id === 'string' && id.length > 0);

  if (!ids.length) {
    console.log('Cleanup: no matching tasks found.');
    return;
  }

  console.log(`Cleanup: deleting ${ids.length} task(s)...`);

  // Best-effort: delete their taskTargets first (so the person timeline is clean)
  for (const id of ids) {
    const targets = await listTaskTargetsByTaskId(id);
    for (const t of targets) {
      if (t?.id) await deleteTaskTarget(t.id);
    }
    await deleteTask(id);
  }
}

async function main() {
  console.log('Script 09: Tasks CRUD (mock data) for a Person');

  if (Number.isNaN(Date.parse(BASE_DUE_ISO))) {
    throw new Error('CONFIG error: BASE_DUE_ISO must be a valid ISO timestamp.');
  }

  if (TASK_COUNT <= 0) {
    throw new Error('CONFIG error: TASK_COUNT must be > 0.');
  }

  const personId = await resolvePersonId();

  const deleteTasksAtEnd = DELETE_TASKS_AT_END;
  const deleteTargetsAtEnd = DELETE_TASK_TARGETS_AT_END;

  console.log('Config:', {
    DRY_RUN,
    DEPTH,
    UPSERT,
    SOFT_DELETE,
    PERSON_ID: PERSON_ID ?? null,
    PERSON_PRIMARY_EMAIL: PERSON_PRIMARY_EMAIL ?? null,
    resolvedPersonId: personId,
    MOCK_NAMESPACE,
    SEED,
    TASK_COUNT,
    BASE_DUE_ISO,
    MIN_DUE_IN_HOURS,
    MAX_DUE_IN_HOURS,
    DELETE_TASKS_AT_END,
    DELETE_TASK_TARGETS_AT_END,
    CLEANUP_EXISTING_BY_NAMESPACE,
  });

  if (CLEANUP_EXISTING_BY_NAMESPACE) {
    await cleanupExistingTasksBestEffort();
  }

  const mockTasks = buildMockTasks({ count: TASK_COUNT, baseDueIso: BASE_DUE_ISO });
  console.log(`Generated ${mockTasks.length} mock task(s).`);

  const createdOrFound: Array<{ id: string; title: string; dueAt?: string; status?: TaskStatus }> = [];
  const taskTargetIds: string[] = [];

  // 1) Find/create and link to person via taskTargets
  for (const task of mockTasks) {
    const title = task.title;
    if (!title) throw new Error('Internal error: generated task missing title.');

    const existing = await findTaskByTitle(title);
    const created = existing
      ? (console.log('Found existing task for title:', title, '->', existing.id), existing)
      : await createTask(task);

    createdOrFound.push({ id: created.id, title, dueAt: created.dueAt ?? task.dueAt, status: created.status ?? task.status });

    const target = await upsertTaskTarget({ taskId: created.id, personId });
    if (target?.id) taskTargetIds.push(target.id);
  }

  // 2) Update (derived; no manual details)
  const updatedIds: string[] = [];
  for (const item of createdOrFound) {
    const nowIso = new Date().toISOString();

    const newDueAt = item.dueAt ? addHours(item.dueAt, 24) : addHours(nowIso, 24);

    const update: TaskPayload = {
      // Keep title stable so subsequent runs can still find by title.
      status: 'IN_PROGRESS',
      dueAt: newDueAt,
      bodyV2: {
        markdown: [
          `**Updated**`,
          '',
          `This task was updated by ${MOCK_NAMESPACE} at ${nowIso}.`,
          '',
          `- Status set to IN_PROGRESS`,
          `- Due moved to: ${newDueAt}`,
        ].join('\n'),
      },
    };

    const updated = await updateTask(item.id, update);
    updatedIds.push(updated.id);
  }

  // 3) Delete (optional)
  const deletedTargetIds: string[] = [];
  const deletedTaskIds: string[] = [];

  if (deleteTargetsAtEnd && taskTargetIds.length) {
    console.log(`Deleting ${taskTargetIds.length} taskTarget(s)...`);
    for (const id of taskTargetIds) {
      const deleted = await deleteTaskTarget(id);
      if (deleted?.id) deletedTargetIds.push(deleted.id);
    }
  }

  if (deleteTasksAtEnd) {
    console.log(`Deleting ${createdOrFound.length} task(s)...`);
    for (const item of createdOrFound) {
      const deleted = await deleteTask(item.id);
      deletedTaskIds.push(deleted.id);
    }
  }

  console.log(
    '\nDone. Summary:\n',
    JSON.stringify(
      {
        namespace: MOCK_NAMESPACE,
        seed: SEED,
        count: TASK_COUNT,
        personId,
        createdOrFound,
        taskTargetIds: deleteTargetsAtEnd ? [] : taskTargetIds,
        updatedIds,
        deletedTargetIds: deleteTargetsAtEnd ? deletedTargetIds : [],
        deletedTaskIds: deleteTasksAtEnd ? deletedTaskIds : [],
      },
      null,
      2,
    ),
  );
}

main().catch((error: any) => {
  const status = error?.response?.status;
  const body = error?.response?.data;
  console.error('❌ Script failed.', {
    status,
    message: error?.message ?? String(error),
    body,
  });
  process.exitCode = 1;
});
